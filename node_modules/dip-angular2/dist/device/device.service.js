import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/Rx';
import { AwgInstrumentService } from './instruments/awg/awg-instrument.service';
import { DcInstrumentService } from './instruments/dc/dc-instrument.service';
import { LaInstrumentService } from './instruments/la/la-instrument.service';
import { OscInstrumentService } from './instruments/osc/osc-instrument.service';
import { TriggerInstrumentService } from './instruments/trigger/trigger-instrument.service';
import { GpioInstrumentService } from './instruments/gpio/gpio-instrument.service';
import { FileService } from './file.service';
import { TransportContainerService } from '../transport/transport-container.service';
export var DeviceService = (function () {
    function DeviceService(_rootUri, deviceDescriptor, httpTimeout) {
        this.instruments = {
            awg: null,
            dc: null,
            la: null,
            osc: null,
            trigger: null,
            gpio: null
        };
        this.firmwareRepositoryUrl = 'https://s3-us-west-2.amazonaws.com/digilent/Software/OpenScope+MZ/release/without-bootloader';
        this.listFirmwareUrl = 'https://s3-us-west-2.amazonaws.com/digilent?prefix=Software/OpenScope+MZ/release/without-bootloader';
        this.descriptorObject = deviceDescriptor;
        this.httpTimeout = httpTimeout;
        this.rootUri = _rootUri;
        this.transport = new TransportContainerService(this.rootUri, httpTimeout);
        if (_rootUri === 'local') {
            this.transport.setLocalTransport(deviceDescriptor);
        }
        this.deviceMake = deviceDescriptor.deviceMake;
        this.deviceModel = deviceDescriptor.deviceModel;
        this.firmwareVersion = deviceDescriptor.firmwareVersion;
        this.calibrationSource = deviceDescriptor.calibrationSource;
        this.macAddress = deviceDescriptor.macAddress;
        this.instruments.awg = new AwgInstrumentService(this.transport, deviceDescriptor.awg);
        this.instruments.dc = new DcInstrumentService(this.transport, deviceDescriptor.dc);
        this.instruments.la = new LaInstrumentService(this.transport, deviceDescriptor.la);
        this.instruments.osc = new OscInstrumentService(this.transport, deviceDescriptor.osc);
        this.instruments.trigger = new TriggerInstrumentService(this.transport, 'deviceDescriptor.trigger');
        this.instruments.gpio = new GpioInstrumentService(this.transport, deviceDescriptor.gpio);
        this.file = new FileService(this.transport);
    }
    DeviceService.prototype.multiCommand = function (commandObject) {
        var _this = this;
        var commandToBeSent = {};
        return Observable.create(function (observer) {
            for (var instrument in commandObject) {
                commandToBeSent[instrument] = {};
                var functionNames = Object.keys(commandObject[instrument]);
                var flag = false;
                for (var _i = 0, functionNames_1 = functionNames; _i < functionNames_1.length; _i++) {
                    var element = functionNames_1[_i];
                    var responseJson = void 0;
                    try {
                        responseJson = (_a = _this.instruments[instrument])[element + 'Json'].apply(_a, commandObject[instrument][element]);
                    }
                    catch (e) {
                        console.log(e);
                        flag = true;
                        observer.error('Error in multiCommand().\nThis is most likely due to an undefined function.\nUnknown function name is: ' + element + 'Json.\nAuto-generated error: ' + e);
                    }
                    if (flag) {
                        return;
                    }
                    for (var channel in responseJson[instrument]) {
                        if (commandToBeSent[instrument][channel] === undefined) {
                            commandToBeSent[instrument][channel] = [];
                            commandToBeSent[instrument][channel] = responseJson[instrument][channel];
                        }
                        else {
                            commandToBeSent[instrument][channel].push(responseJson[instrument][channel][0]);
                        }
                    }
                }
            }
            //MultiCommand packet is complete. Now to send
            var multiCommandResponse;
            console.log('multicommand: ');
            console.log(commandToBeSent);
            _this.transport.writeRead('/', JSON.stringify(commandToBeSent), 'json').subscribe(function (arrayBuffer) {
                var firstChar = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(0, 1)));
                if (!isNaN(parseInt(firstChar))) {
                    //TODO switch to chunked transfer
                    var count = 0;
                    var i = 0;
                    var stringBuffer = '';
                    while (count < 2 && i < 10000) {
                        var char = '';
                        char += String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(i, i + 1)));
                        if (char === '\n') {
                            count++;
                        }
                        stringBuffer += char;
                        i++;
                    }
                    var binaryIndexStringLength = stringBuffer.indexOf('\r\n');
                    var binaryIndex = parseFloat(stringBuffer.substring(0, binaryIndexStringLength));
                    var command = void 0;
                    var binaryData = void 0;
                    try {
                        command = JSON.parse(stringBuffer.substring(binaryIndexStringLength + 2, binaryIndexStringLength + binaryIndex + 2));
                        binaryData = arrayBuffer.slice(binaryIndexStringLength + 2 + binaryIndex);
                    }
                    catch (error) {
                        console.log('Error parsing OSJB response. Printing entire response');
                        console.log(String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(0))));
                        observer.error(error);
                        return;
                    }
                    //Command parsed. Now calling individual parsing functions
                    var flag = false;
                    for (var instrument in command) {
                        for (var channel in command[instrument]) {
                            for (var _i = 0, _a = command[instrument][channel]; _i < _a.length; _i++) {
                                var responseObject = _a[_i];
                                try {
                                    if (responseObject.command === 'read') {
                                        console.log(responseObject);
                                        observer.next(_this.instruments[instrument][responseObject.command + 'Parse'](channel, command, binaryData));
                                    }
                                    else {
                                        observer.next(_this.instruments[instrument][responseObject.command + 'Parse'](channel, responseObject));
                                    }
                                }
                                catch (e) {
                                    console.log(e);
                                    flag = true;
                                    observer.error('Error in multiCommand().\nThis is most likely due to an undefined function.\nUnknown function name is: ' + responseObject.command + 'Parse.\nAuto-generated error: ' + e);
                                }
                                if (flag)
                                    return;
                            }
                        }
                    }
                    observer.next('OSJB whaddup');
                    observer.complete();
                }
                else if (firstChar === '{') {
                    //JSON
                    try {
                        console.log(String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(0))));
                        multiCommandResponse = JSON.parse(String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(0))));
                    }
                    catch (e) {
                        console.log(e);
                        observer.error('Error in multiCommand().\nThis is most likely due to an unparseable response.\nAuto-generated error: ' + e);
                    }
                    //Response Received! Now to reparse and call observer.next for each command
                    var flag = false;
                    for (var instrument in multiCommandResponse) {
                        for (var channel in multiCommandResponse[instrument]) {
                            for (var _b = 0, _c = multiCommandResponse[instrument][channel]; _b < _c.length; _b++) {
                                var responseObject = _c[_b];
                                try {
                                    if (responseObject.statusCode > 0) {
                                        console.log('StatusCode Error!');
                                        observer.error(responseObject);
                                        flag = true;
                                    }
                                    observer.next(_this.instruments[instrument][responseObject.command + 'Parse'](channel, responseObject));
                                }
                                catch (e) {
                                    console.log(e);
                                    flag = true;
                                    observer.error('Error in multiCommand().\nThis is most likely due to an undefined function.\nUnknown function name is: ' + responseObject.command + 'Parse.\nAuto-generated error: ' + e);
                                }
                                if (flag) {
                                    return;
                                }
                            }
                        }
                    }
                    observer.complete();
                }
                else {
                    observer.error('Error in multiCommand().\nThis is most likely due to an unrecognized response format. Exiting');
                }
            }, function (err) {
                console.log(err);
                observer.error('Error in multiCommand().\nThis is most likely due to no device being detected.');
            }, function () {
            });
            var _a;
        });
    };
    DeviceService.prototype._genericResponseHandler = function (commandObject) {
        var _this = this;
        return Observable.create(function (observer) {
            _this.transport.writeRead('/', JSON.stringify(commandObject), 'json').subscribe(function (arrayBuffer) {
                var data;
                try {
                    var stringify = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(0)));
                    console.log(stringify);
                    data = JSON.parse(stringify);
                }
                catch (e) {
                    observer.error(e);
                    return;
                }
                if (data.device == undefined || data.device[0].statusCode > 0 || data.agent != undefined) {
                    observer.error(data);
                    return;
                }
                observer.next(data);
                //Handle device errors and warnings
                observer.complete();
            }, function (err) {
                observer.error(err);
            }, function () {
                observer.complete();
            });
        });
    };
    DeviceService.prototype.resetInstruments = function () {
        var command = {
            device: [{
                    command: 'resetInstruments'
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.storageGetLocations = function () {
        var command = {
            "device": [{
                    command: "storageGetLocations"
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.calibrationGetStorageTypes = function () {
        var command = {
            "device": [{
                    command: "calibrationGetStorageTypes"
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.calibrationGetInstructions = function () {
        var command = {
            "device": [{
                    command: "calibrationGetInstructions"
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.calibrationStart = function () {
        var command = {
            "device": [{
                    command: "calibrationStart"
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.calibrationLoad = function (type) {
        var command = {
            "device": [{
                    "command": "calibrationLoad",
                    "type": type
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.calibrationRead = function () {
        var command = {
            "device": [{
                    command: "calibrationRead"
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.calibrationSave = function (type) {
        var command = {
            "device": [{
                    "command": "calibrationSave",
                    "type": type
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.calibrationGetStatus = function () {
        var command = {
            "device": [{
                    "command": "calibrationGetStatus"
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.nicList = function () {
        var command = {
            "device": [{
                    command: "nicList"
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.nicGetStatus = function (adapter) {
        var command = {
            "device": [{
                    command: "nicGetStatus",
                    adapter: adapter
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.nicConnect = function (adapter, parameterSet, force) {
        var command = {
            "device": [{
                    command: "nicConnect",
                    adapter: adapter,
                    parameterSet: parameterSet,
                    force: force
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.nicDisconnect = function (adapter) {
        var command = {
            "device": [{
                    command: "nicDisconnect",
                    adapter: adapter
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.wifiScan = function (adapter) {
        var command = {
            "device": [{
                    command: "wifiScan",
                    adapter: adapter
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.wifiReadScannedNetworks = function (adapter) {
        var command = {
            "device": [{
                    command: "wifiReadScannedNetworks",
                    adapter: adapter
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.wifiSetParameters = function (adapter, ssid, securityType, autoConnect, passphrase, keys, keyIndex) {
        var command = {
            "device": [{
                    "command": "wifiSetParameters",
                    "ssid": ssid,
                    "securityType": securityType,
                    "autoConnect": autoConnect
                }]
        };
        if (securityType === 'wep40' || securityType === 'wep104') {
            command.device[0]['keys'] = keys;
            command.device[0]['keyIndex'] = keyIndex;
        }
        else if (securityType === 'wpa' || securityType === 'wpa2') {
            if (passphrase) {
                command.device[0]['passphrase'] = passphrase;
            }
            else {
                command.device[0]['keys'] = keys;
            }
        }
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.wifiListSavedParameters = function (storageLocation) {
        var command = {
            "device": [{
                    command: "wifiListSavedParameters",
                    storageLocation: storageLocation
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.wifiDeleteParameters = function (storageLocation, ssid) {
        var command = {
            "device": [{
                    command: "wifiDeleteParameters",
                    storageLocation: storageLocation,
                    ssid: ssid
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.wifiSaveParameters = function (storageLocation) {
        var command = {
            "device": [{
                    command: "wifiSaveParameters",
                    storageLocation: storageLocation
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.prototype.wifiLoadParameters = function (storageLocation, ssid) {
        var command = {
            "device": [{
                    command: "wifiLoadParameters",
                    storageLocation: storageLocation,
                    ssid: ssid
                }]
        };
        return this._genericResponseHandler(command);
    };
    DeviceService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DeviceService.ctorParameters = [
        null,
        null,
        null,
    ];
    return DeviceService;
}());
//# sourceMappingURL=device.service.js.map