var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/Rx';
import { GenericInstrumentService } from '../generic-instrument.service';
import { DcChannelService } from './dc-channel.service';
import { TransportContainerService } from '../../../transport/transport-container.service';
export var DcInstrumentService = (function (_super) {
    __extends(DcInstrumentService, _super);
    function DcInstrumentService(_transport, _dcInstrumentDescriptor) {
        _super.call(this, _transport, '/');
        this.chans = [];
        //Populate DC supply parameters
        this.numChans = _dcInstrumentDescriptor.numChans;
        //Populate channels        
        for (var key in _dcInstrumentDescriptor) {
            if (key !== 'numChans') {
                this.chans.push(new DcChannelService(_dcInstrumentDescriptor[key]));
            }
        }
    }
    //Get the output voltage(s) of the specified DC power supply channel(s).
    DcInstrumentService.prototype.getVoltagesJson = function (chans) {
        var command = {
            "dc": {}
        };
        chans.forEach(function (element, index, array) {
            command.dc[chans[index]] =
                [
                    {
                        "command": "getVoltage"
                    }
                ];
        });
        return command;
    };
    DcInstrumentService.prototype.getVoltageParse = function (chan, responseObject) {
        return 'Channel ' + chan + ' ' + responseObject.command + ' successful';
    };
    DcInstrumentService.prototype.setVoltagesJson = function (chans, voltages) {
        var scaledVoltages = [];
        var command = {
            "dc": {}
        };
        voltages.forEach(function (element, index, array) {
            scaledVoltages.push(element * 1000);
            command.dc[chans[index]] =
                [
                    {
                        "command": "setVoltage",
                        "voltage": Math.round(element * 1000)
                    }
                ];
        });
        return command;
    };
    DcInstrumentService.prototype.setVoltageParse = function (chan, responseObject) {
        return 'Channel ' + chan + ' ' + responseObject.command + ' successful';
    };
    DcInstrumentService.prototype.getVoltages = function (chans) {
        var _this = this;
        var command = this.getVoltagesJson(chans);
        return Observable.create(function (observer) {
            _super.prototype._genericResponseHandler.call(_this, command).subscribe(function (data) {
                for (var i = 0; i < chans.length; i++) {
                    if (data.dc == undefined || data.dc[chans[i]][0].statusCode > 0 || data.agent != undefined) {
                        observer.error(data);
                        return;
                    }
                    data.dc[chans[i]][0].voltage = data.dc[chans[i]][0].voltage / 1000;
                }
                //Return voltages and complete observer
                observer.next(data);
                observer.complete();
            }, function (err) {
                observer.error(err);
            }, function () { });
        });
    };
    //Set the output voltage of the specified DC power supply channel.
    DcInstrumentService.prototype.setVoltages = function (chans, voltages) {
        var command = this.setVoltagesJson(chans, voltages);
        return _super.prototype._genericResponseHandler.call(this, command);
    };
    //Streaming read voltages from the specified channel(s)
    DcInstrumentService.prototype.streamReadVoltages = function (chans, delay) {
        var _this = this;
        if (delay === void 0) { delay = 0; }
        var command = {
            command: "dcGetVoltages",
            chans: chans
        };
        return Observable.create(function (observer) {
            _this.transport.streamFrom(_this.endpoint, JSON.stringify(command), 'json', delay).subscribe(function (arrayBuffer) {
                var data = JSON.parse(String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(0))));
                //Handle device errors and warnings
                for (var i = 0; i < chans.length; i++) {
                    if (data.dc == undefined || data.dc[chans[i]][0].statusCode > 0 || data.agent != undefined) {
                        observer.error(data);
                        return;
                    }
                }
                //Scale from mV to V                            
                data.voltages.forEach(function (element, index, array) {
                    array[index] = element / 1000;
                });
                observer.next(data.voltages);
            }, function (err) {
                observer.error(err);
            }, function () {
                observer.complete();
            });
        });
    };
    //Stop the current stream
    DcInstrumentService.prototype.stopStream = function () {
        this.transport.stopStream();
    };
    DcInstrumentService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DcInstrumentService.ctorParameters = [
        { type: TransportContainerService, },
        null,
    ];
    return DcInstrumentService;
}(GenericInstrumentService));
//# sourceMappingURL=dc-instrument.service.js.map