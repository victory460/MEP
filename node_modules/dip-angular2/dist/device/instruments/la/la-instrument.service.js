var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/Rx';
import { LaChannelService } from './la-channel.service';
import { GenericInstrumentService } from '../generic-instrument.service';
import { WaveformService } from '../../../data-types/waveform.service';
import { TransportContainerService } from '../../../transport/transport-container.service';
import { CommandUtilityService } from '../../../utilities/command-utility.service';
export var LaInstrumentService = (function (_super) {
    __extends(LaInstrumentService, _super);
    function LaInstrumentService(_transport, _laInstrumentDescriptor) {
        _super.call(this, _transport, '/');
        this.chans = [];
        this.numDataBuffers = 8;
        this.dataBuffer = [];
        this.dataBufferWriteIndex = 0;
        this.dataBufferReadIndex = 0;
        //Populate LA supply parameters
        this.numChans = _laInstrumentDescriptor.numChans;
        this.commandUtilityService = new CommandUtilityService();
        //Populate channels  
        for (var channel in _laInstrumentDescriptor) {
            if (channel !== 'numChans') {
                this.chans.push(new LaChannelService(_laInstrumentDescriptor[channel]));
            }
        }
        for (var i = 0; i < this.numDataBuffers; i++) {
            this.dataBuffer.push([]);
        }
    }
    LaInstrumentService.prototype.getCurrentStateJson = function (chans) {
        var command = {
            la: {}
        };
        chans.forEach(function (element, index, array) {
            command.la[chans[index]] =
                [
                    {
                        command: "getCurrentState"
                    }
                ];
        });
        return command;
    };
    LaInstrumentService.prototype.getCurrentState = function (chans) {
        var command = this.getCurrentStateJson(chans);
        return _super.prototype._genericResponseHandler.call(this, command);
    };
    LaInstrumentService.prototype.setParametersJson = function (chans, bitmasks, sampleFreqs, bufferSizes, triggerDelays) {
        var command = {
            "la": {}
        };
        chans.forEach(function (element, index, array) {
            command.la[chans[index]] =
                [
                    {
                        command: "setParameters",
                        bitmask: bitmasks[index],
                        triggerDelay: Math.round(triggerDelays[index] * Math.pow(10, 12)),
                        sampleFreq: Math.round(sampleFreqs[index] * 1000),
                        bufferSize: bufferSizes[index]
                    }
                ];
        });
        return command;
    };
    LaInstrumentService.prototype.setParametersParse = function (chan, responseObject) {
        return 'Channel ' + chan + ' ' + responseObject.command + ' successful';
    };
    //Tell OpenScope to run once and return a buffer
    LaInstrumentService.prototype.setParameters = function (chans, bitmasks, sampleFreqs, bufferSizes, triggerDelays) {
        if (chans.length == 0) {
            return Observable.create(function (observer) {
                observer.complete();
            });
        }
        var command = this.setParametersJson(chans, bitmasks, sampleFreqs, bufferSizes, triggerDelays);
        return _super.prototype._genericResponseHandler.call(this, command);
    };
    //Tell OpenScope to run once and return a buffer
    LaInstrumentService.prototype.read = function (chans) {
        var _this = this;
        if (chans.length == 0) {
            return Observable.create(function (observer) {
                observer.complete();
            });
        }
        var command = {
            "la": {}
        };
        chans.forEach(function (element, index, array) {
            command.la[chans[index]] =
                [
                    {
                        "command": "read"
                    }
                ];
        });
        console.log('READREADREADREAD');
        return Observable.create(function (observer) {
            _this.transport.writeRead('/', JSON.stringify(command), 'json').subscribe(function (data) {
                _this.rawPacket = data;
                var start = performance.now();
                _this.commandUtilityService.observableParseChunkedTransfer(data).subscribe(function (data) {
                    var command = data.json;
                    var channelsObject = {};
                    var binaryData;
                    console.log('la response received');
                    console.log(command);
                    try {
                        binaryData = new Int16Array(data.typedArray.slice(command.la[chans[0].toString()][0].binaryOffset, command.la[chans[0].toString()][0].binaryOffset + command.la[chans[0].toString()][0].binaryLength));
                    }
                    catch (e) {
                        console.log(e);
                        observer.error(e);
                        return;
                    }
                    var untypedArray = Array.prototype.slice.call(binaryData);
                    _this.dataBuffer[_this.dataBufferWriteIndex] = [];
                    for (var group in command.la) {
                        if (command.la[group][0].statusCode > 0) {
                            observer.error(command);
                            return;
                        }
                        var binaryString = command.la[group][0].bitmask.toString(2);
                        console.log(binaryString);
                        for (var i = 0; i < binaryString.length; i++) {
                            console.log(binaryString[i]);
                            if (binaryString[i] === '1') {
                                var channel = binaryString.length - i;
                                channelsObject[channel] = [];
                                var andVal = Math.pow(2, channel - 1);
                                var dt = 1 / (command.la[group][0].actualSampleFreq / 1000);
                                var pointContainer = [];
                                var triggerPosition = command.la[group][0].triggerIndex * dt;
                                if (triggerPosition < 0) {
                                    console.log('trigger not in la buffer!');
                                    triggerPosition = command.la[group][0].triggerDelay;
                                }
                                for (var j = 0; j < untypedArray.length; j++) {
                                    channelsObject[channel].push((andVal & untypedArray[j]) > 0 ? 1 : 0);
                                    pointContainer.push([j * dt - triggerPosition, (andVal & untypedArray[j]) > 0 ? 1 : 0]);
                                }
                                _this.dataBuffer[_this.dataBufferWriteIndex][channel - 1] = new WaveformService({
                                    dt: 1 / (command.la[group][0].actualSampleFreq / 1000),
                                    t0: 0,
                                    y: channelsObject[channel],
                                    data: pointContainer,
                                    pointOfInterest: command.la[group][0].pointOfInterest,
                                    triggerPosition: triggerPosition,
                                    seriesOffset: 0.5,
                                    triggerDelay: (command.la[group][0].triggerDelay == undefined ? command.la[group][0].actualTriggerDelay : command.la[group][0].triggerDelay)
                                });
                            }
                        }
                    }
                    _this.dataBufferReadIndex = _this.dataBufferWriteIndex;
                    _this.dataBufferWriteIndex = (_this.dataBufferWriteIndex + 1) % _this.numDataBuffers;
                    var finish = performance.now();
                    console.log('Time: ' + (finish - start));
                    console.log(channelsObject);
                    observer.next(command);
                    //Handle device errors and warnings
                    observer.complete();
                }, function (err) {
                    observer.error(data);
                }, function () { });
            }, function (err) {
                observer.error(err);
            }, function () {
                observer.complete();
            });
        });
    };
    LaInstrumentService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    LaInstrumentService.ctorParameters = [
        { type: TransportContainerService, },
        null,
    ];
    return LaInstrumentService;
}(GenericInstrumentService));
//# sourceMappingURL=la-instrument.service.js.map