var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/Rx';
import { GenericInstrumentService } from '../generic-instrument.service';
import { TransportContainerService } from '../../../transport/transport-container.service';
export var TriggerInstrumentService = (function (_super) {
    __extends(TriggerInstrumentService, _super);
    function TriggerInstrumentService(_transport, _triggerInstrumentDescriptor) {
        _super.call(this, _transport, '/');
        this.chans = [];
    }
    TriggerInstrumentService.prototype.setParametersJson = function (chans, sources, targetsArray) {
        var command = {
            "trigger": {}
        };
        chans.forEach(function (element, index, array) {
            command.trigger[chans[index]] =
                [
                    {
                        "command": "setParameters",
                        "source": sources[index],
                        "targets": targetsArray[index]
                    }
                ];
        });
        return command;
    };
    TriggerInstrumentService.prototype.setParametersParse = function (chan, command) {
        return 'set Parameters channel ' + chan + ' is done!';
    };
    //Tell OpenScope to run once and return a buffer
    TriggerInstrumentService.prototype.setParameters = function (chans, sources, targetsArray) {
        if (chans.length == 0) {
            return Observable.create(function (observer) {
                observer.complete();
            });
        }
        var command = this.setParametersJson(chans, sources, targetsArray);
        return _super.prototype._genericResponseHandler.call(this, command);
    };
    TriggerInstrumentService.prototype.getCurrentState = function (chans) {
        var command = this.getCurrentStateJson(chans);
        return _super.prototype._genericResponseHandler.call(this, command);
    };
    TriggerInstrumentService.prototype.getCurrentStateJson = function (chans) {
        var command = {
            trigger: {}
        };
        chans.forEach(function (element, index, array) {
            command.trigger[chans[index]] =
                [
                    {
                        command: 'getCurrentState'
                    }
                ];
        });
        return command;
    };
    TriggerInstrumentService.prototype.getCurrentStateParse = function (chan, responseObject) {
        return 'Success';
    };
    TriggerInstrumentService.prototype.singleJson = function (chans) {
        var command = {
            "trigger": {}
        };
        chans.forEach(function (element, index, array) {
            command.trigger[chans[index]] =
                [
                    {
                        "command": "single"
                    }
                ];
        });
        return command;
    };
    TriggerInstrumentService.prototype.singleParse = function (chan, command) {
        return 'single channel ' + chan + ' is done';
    };
    TriggerInstrumentService.prototype.single = function (chans) {
        //If no channels are active no need to talk to hardware
        if (chans.length == 0) {
            return Observable.create(function (observer) {
                observer.complete();
            });
        }
        var command = this.singleJson(chans);
        return _super.prototype._genericResponseHandler.call(this, command);
    };
    TriggerInstrumentService.prototype.stopJson = function (chans) {
        var command = {
            trigger: {}
        };
        chans.forEach(function (element, index, array) {
            command.trigger[chans[index]] = [{
                    command: "stop"
                }];
        });
        return command;
    };
    TriggerInstrumentService.prototype.stopParse = function (chan, command) {
        return 'stop done';
    };
    TriggerInstrumentService.prototype.stop = function (chans) {
        if (chans.length == 0) {
            return Observable.create(function (observer) {
                observer.complete();
            });
        }
        var command = this.stopJson(chans);
        return _super.prototype._genericResponseHandler.call(this, command);
    };
    TriggerInstrumentService.prototype.forceTriggerJson = function (chans) {
        var command = {
            "trigger": {}
        };
        chans.forEach(function (element, index, array) {
            command.trigger[chans[index]] =
                [
                    {
                        "command": "forceTrigger"
                    }
                ];
        });
        return command;
    };
    TriggerInstrumentService.prototype.forceTriggerParse = function (chan, command) {
        return 'force trigger done';
    };
    TriggerInstrumentService.prototype.forceTrigger = function (chans) {
        //If no channels are active no need to talk to hardware
        if (chans.length == 0) {
            return Observable.create(function (observer) {
                observer.complete();
            });
        }
        var command = this.forceTriggerJson(chans);
        return _super.prototype._genericResponseHandler.call(this, command);
    };
    TriggerInstrumentService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    TriggerInstrumentService.ctorParameters = [
        { type: TransportContainerService, },
        null,
    ];
    return TriggerInstrumentService;
}(GenericInstrumentService));
//# sourceMappingURL=trigger-instrument.service.js.map