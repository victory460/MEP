var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/Rx';
import { GenericInstrumentService } from '../generic-instrument.service';
import { AwgChannelService } from './awg-channel.service';
import { TransportContainerService } from '../../../transport/transport-container.service';
export var AwgInstrumentService = (function (_super) {
    __extends(AwgInstrumentService, _super);
    function AwgInstrumentService(_transport, _awgInstrumentDescriptor) {
        _super.call(this, _transport, '/');
        this.chans = [];
        //Populate AWG supply parameters
        this.numChans = _awgInstrumentDescriptor.numChans;
        //Populate channels  
        for (var key in _awgInstrumentDescriptor) {
            if (key !== 'numChans') {
                this.chans.push(new AwgChannelService(_awgInstrumentDescriptor[key]));
            }
        }
    }
    AwgInstrumentService.prototype.setArbitraryWaveform = function (chans, waveforms, dataTypes) {
        var _this = this;
        var command = {
            "awg": {}
        };
        var binaryOffset = 0;
        var binaryLength = 0;
        chans.forEach(function (element, index, array) {
            //Hard code 2 bytes per value
            //TODO read data types and generate length from that instead of hard code
            binaryLength = waveforms[index].y.length * 2;
            command.awg[chans[index]] =
                [
                    {
                        command: "setArbitraryWaveform",
                        binaryOffset: binaryOffset,
                        binaryLength: binaryLength,
                        binaryType: dataTypes[index],
                        vpp: 3,
                        vOffset: 0,
                        dt: waveforms[index].dt
                    }
                ];
            binaryOffset += binaryLength;
        });
        var stringCommand = JSON.stringify(command) + '\r\n';
        var jsonChars = stringCommand.length;
        var fullString = jsonChars + '\r\n' + stringCommand;
        var binaryBufferToSend = new ArrayBuffer(fullString.length + binaryOffset);
        for (var i = 0; i < fullString.length; i++) {
            binaryBufferToSend[i] = fullString.charCodeAt(i);
        }
        for (var i = 0; i < chans.length; i++) {
            var typedArray = new Int16Array(waveforms[i].y);
            var byteConvert = new Uint8Array(typedArray.buffer);
            for (var i_1 = fullString.length, j = 0; i_1 < binaryOffset + fullString.length; i_1 = i_1 + 2, j = j + 2) {
                binaryBufferToSend[i_1] = byteConvert[j];
                binaryBufferToSend[i_1 + 1] = byteConvert[j + 1];
            }
        }
        return Observable.create(function (observer) {
            _this.transport.writeRead(_this.endpoint, binaryBufferToSend, 'binary').subscribe(function (arrayBuffer) {
                var data = JSON.parse(String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(0))));
                for (var i = 0; i < chans.length; i++) {
                    if (data.awg == undefined || data.awg[chans[i]][0].statusCode > 0 || data.agent != undefined) {
                        observer.error(data);
                        return;
                    }
                }
                observer.next(data);
                observer.complete();
            }, function (err) {
                observer.error(err);
            }, function () {
                observer.complete();
            });
        });
    };
    AwgInstrumentService.prototype.getCurrentState = function (chans) {
        var command = {
            awg: {}
        };
        chans.forEach(function (element, index, array) {
            command.awg[chans[index]] =
                [{
                        command: "getCurrentState"
                    }];
        });
        return _super.prototype._genericResponseHandler.call(this, command);
    };
    AwgInstrumentService.prototype.setRegularWaveform = function (chans, settings) {
        var command = {
            "awg": {}
        };
        chans.forEach(function (element, index, array) {
            command.awg[chans[index]] =
                [
                    {
                        command: "setRegularWaveform",
                        signalType: settings[index].signalType,
                        signalFreq: Math.floor(settings[index].signalFreq * 1000),
                        vpp: Math.floor(settings[index].vpp * 1000),
                        vOffset: Math.floor(settings[index].vOffset * 1000)
                    }
                ];
        });
        return _super.prototype._genericResponseHandler.call(this, command);
    };
    AwgInstrumentService.prototype.setRegularWaveformJson = function (chans, settings) {
        var command = {
            "awg": {}
        };
        chans.forEach(function (element, index, array) {
            command.awg[chans[index]] =
                [
                    {
                        command: "setRegularWaveform",
                        signalType: settings[index].signalType,
                        signalFreq: Math.floor(settings[index].signalFreq * 1000),
                        vpp: Math.floor(settings[index].vpp * 1000),
                        vOffset: Math.floor(settings[index].vOffset * 1000)
                    }
                ];
        });
        return command;
    };
    AwgInstrumentService.prototype.setRegularWaveformParse = function (chan, responseObject) {
        return responseObject;
    };
    AwgInstrumentService.prototype.runJson = function (chans) {
        var command = {
            "awg": {}
        };
        chans.forEach(function (element, index, array) {
            command.awg[chans[index]] =
                [
                    {
                        command: "run"
                    }
                ];
        });
        return command;
    };
    AwgInstrumentService.prototype.runParse = function (chan, responseObject) {
        return responseObject;
    };
    AwgInstrumentService.prototype.run = function (chans) {
        var command = {
            "awg": {}
        };
        chans.forEach(function (element, index, array) {
            command.awg[chans[index]] =
                [
                    {
                        command: "run"
                    }
                ];
        });
        return _super.prototype._genericResponseHandler.call(this, command);
    };
    AwgInstrumentService.prototype.stop = function (chans) {
        var command = {
            "awg": {}
        };
        chans.forEach(function (element, index, array) {
            command.awg[chans[index]] =
                [
                    {
                        command: "stop"
                    }
                ];
        });
        return _super.prototype._genericResponseHandler.call(this, command);
    };
    AwgInstrumentService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    AwgInstrumentService.ctorParameters = [
        { type: TransportContainerService, },
        null,
    ];
    return AwgInstrumentService;
}(GenericInstrumentService));
//# sourceMappingURL=awg-instrument.service.js.map