import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/Rx';
import { DeviceService } from './device.service';
import { TransportContainerService } from '../transport/transport-container.service';
export var DeviceManagerService = (function () {
    function DeviceManagerService() {
        this.devices = [];
        this.httpTimeout = 5000;
        this.transport = new TransportContainerService(null, this.httpTimeout);
    }
    DeviceManagerService.prototype.setHttpTimeout = function (newTimeout) {
        this.httpTimeout = newTimeout;
        this.transport.setHttpTimeout(newTimeout);
        for (var i = 0; i < this.devices.length; i++) {
            this.devices[i].transport.setHttpTimeout(newTimeout);
        }
    };
    DeviceManagerService.prototype.getHttpTimeout = function () {
        return this.httpTimeout;
    };
    //Connect to device and send enumerate command
    DeviceManagerService.prototype.connect = function (uri) {
        var _this = this;
        return Observable.create(function (observer) {
            _this.transport.setHttpTransport(uri);
            var command = {
                'device': [
                    {
                        command: 'enumerate'
                    }
                ]
            };
            _this.transport.writeRead('/', JSON.stringify(command), 'json').subscribe(function (deviceDescriptor) {
                var response;
                try {
                    response = JSON.parse(String.fromCharCode.apply(null, new Int8Array(deviceDescriptor.slice(0))));
                }
                catch (error) {
                    observer.error(error);
                    return;
                }
                observer.next(response);
                observer.complete();
            }, function (err) {
                observer.error(err);
            }, function () {
                observer.complete();
            });
        });
    };
    DeviceManagerService.prototype.connectBridge = function (uri) {
        var _this = this;
        return Observable.create(function (observer) {
            _this.transport.setHttpTransport(uri);
            var command = {
                "agent": [
                    {
                        "command": "enumerateDevices"
                    }
                ]
            };
            _this.transport.writeRead('/config', JSON.stringify(command), 'json').subscribe(function (data) {
                var response;
                try {
                    response = JSON.parse(String.fromCharCode.apply(null, new Int8Array(data.slice(0))));
                }
                catch (error) {
                    observer.error(error);
                }
                observer.next(response);
                observer.complete();
            }, function (err) {
                observer.error(err);
            }, function () {
                observer.complete();
            });
        });
    };
    DeviceManagerService.prototype.connectLocal = function (deviceName) {
        var _this = this;
        return Observable.create(function (observer) {
            if (deviceName === 'OpenScope MZ') {
                var XHR = new XMLHttpRequest();
                // We define what will happen if the data are successfully sent
                XHR.addEventListener("load", function (event) {
                    var enumerationObject;
                    try {
                        enumerationObject = JSON.parse(event.currentTarget.response);
                    }
                    catch (e) {
                        observer.error(e);
                        return;
                    }
                    this.transport.setLocalTransport(enumerationObject);
                    var command = {
                        'device': [
                            {
                                command: 'enumerate'
                            }
                        ]
                    };
                    this.transport.writeRead('/', JSON.stringify(command), 'json').subscribe(function (deviceDescriptor) {
                        var response = JSON.parse(String.fromCharCode.apply(null, new Int8Array(deviceDescriptor.slice(0))));
                        observer.next(response);
                        observer.complete();
                    }, function (err) {
                        observer.error(err);
                    }, function () {
                        observer.complete();
                    });
                }.bind(_this));
                // We define what will happen in case of error
                XHR.addEventListener("error", function (event) {
                    observer.error('TX Error: ', event);
                });
                // We set up our request
                XHR.open("GET", 'assets/devices/openscope-mz/descriptor.json');
                XHR.send();
            }
        });
    };
    //Return active device
    DeviceManagerService.prototype.getActiveDevice = function () {
        return this.devices[this.activeDeviceIndex];
    };
    //Sets active device
    DeviceManagerService.prototype.setActiveDevice = function (_activeDeviceIndex) {
        this.activeDeviceIndex = _activeDeviceIndex;
    };
    DeviceManagerService.prototype.addDeviceFromDescriptor = function (uri, deviceDescriptor) {
        var deviceExistCheck = this.deviceExists(uri, deviceDescriptor);
        if (deviceExistCheck !== -1) {
            this.activeDeviceIndex = deviceExistCheck;
            return;
        }
        var dev = new DeviceService(uri, deviceDescriptor.device[0], this.httpTimeout);
        this.activeDeviceIndex = this.devices.push(dev) - 1;
    };
    DeviceManagerService.prototype.deviceExists = function (uri, deviceDescriptor) {
        var descriptorString = JSON.stringify(deviceDescriptor.device[0]);
        for (var i = 0; i < this.devices.length; i++) {
            if (JSON.stringify(this.devices[i].descriptorObject) === descriptorString && this.devices[i].rootUri === uri) {
                console.log('device exists!');
                return i;
            }
        }
        return -1;
    };
    DeviceManagerService.prototype.xmlToJson = function (data) {
        var parser = new DOMParser();
        var xmlDoc;
        var contents;
        try {
            xmlDoc = parser.parseFromString(data, "text/xml");
            contents = xmlDoc.getElementsByTagName("Contents");
        }
        catch (e) {
            return e;
        }
        var returnArray = [];
        for (var i = 0; i < contents.length; i++) {
            returnArray.push({});
            for (var j = 0; j < contents[i].childNodes.length; j++) {
                try {
                    returnArray[i][contents[i].childNodes[j].tagName] = contents[i].childNodes[j].textContent;
                }
                catch (e) {
                    return e;
                }
            }
        }
        var arrayToSort = [];
        for (var i = 0; i < returnArray.length; i++) {
            var splitArray = returnArray[i].Key.split('.');
            if (splitArray[splitArray.length - 1] !== 'hex') {
                continue;
            }
            var patch = splitArray[splitArray.length - 2];
            var minor = splitArray[splitArray.length - 3];
            var major = splitArray[splitArray.length - 4].slice(-1);
            var versionNum = major + '.' + minor + '.' + patch;
            arrayToSort.push(versionNum);
        }
        arrayToSort.sort(function (a, b) {
            var aSplit = a.split('.');
            var bSplit = b.split('.');
            var aPriority = parseInt(aSplit[0]) * 1000000 + parseInt(aSplit[1]) * 1000 + parseInt(aSplit[2]);
            var bPriority = parseInt(bSplit[0]) * 1000000 + parseInt(bSplit[1]) * 1000 + parseInt(bSplit[2]);
            return aPriority - bPriority;
        });
        return arrayToSort;
    };
    DeviceManagerService.prototype.getLatestFirmwareVersionFromArray = function (firmwareVersionsArray) {
        firmwareVersionsArray.sort(function (a, b) {
            var aSplit = a.split('.');
            var bSplit = b.split('.');
            var aPriority = parseInt(aSplit[0]) * 1000000 + parseInt(aSplit[1]) * 1000 + parseInt(aSplit[2]);
            var bPriority = parseInt(bSplit[0]) * 1000000 + parseInt(bSplit[1]) * 1000 + parseInt(bSplit[2]);
            return bPriority - aPriority;
        });
        return firmwareVersionsArray[0];
    };
    DeviceManagerService.prototype.getLatestFirmwareVersionFromUrl = function (firmwareUrl) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.getFirmwareVersionsFromUrl(firmwareUrl).then(function (firmwareVersionsArray) {
                resolve(_this.getLatestFirmwareVersionFromArray(firmwareVersionsArray));
            }).catch(function (e) {
                reject(e);
            });
        });
    };
    DeviceManagerService.prototype.getFirmwareVersionsFromUrl = function (firmwareUrl) {
        var _this = this;
        this.transport.setHttpTransport(this.transport.getUri());
        return new Promise(function (resolve, reject) {
            _this.transport.getRequest(firmwareUrl).subscribe(function (data) {
                if (data.indexOf('xml') === -1) {
                    reject('Error');
                }
                resolve(_this.xmlToJson(data));
            }, function (err) {
                reject(err);
            }, function () { });
        });
    };
    DeviceManagerService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DeviceManagerService.ctorParameters = [];
    return DeviceManagerService;
}());
//# sourceMappingURL=device-manager.service.js.map