import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/Rx';
export var CommandUtilityService = (function () {
    function CommandUtilityService() {
    }
    CommandUtilityService.prototype.parseChunkedTransfer = function (data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var firstChar = String.fromCharCode.apply(null, new Uint8Array(data.slice(0, 1)));
            if (isNaN(parseInt(firstChar, 16))) {
                reject('json or bad packet');
                return;
            }
            var chunkGuardLength = 100;
            var currentReadIndex = 0;
            var chunkLength;
            var chunkInfo = _this._findNewLineChar(chunkGuardLength, data, currentReadIndex);
            chunkLength = _this._getChunkLength(chunkInfo.stringBuffer);
            currentReadIndex = chunkInfo.endingIndex;
            var jsonPortion;
            try {
                jsonPortion = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(data.slice(currentReadIndex, currentReadIndex + chunkLength + 2))));
            }
            catch (e) {
                reject(e);
                return;
            }
            currentReadIndex = currentReadIndex + chunkLength + 2;
            chunkInfo = _this._findNewLineChar(chunkGuardLength, data, currentReadIndex);
            chunkLength = _this._getChunkLength(chunkInfo.stringBuffer);
            currentReadIndex = chunkInfo.endingIndex;
            var binaryDataSlice = data.slice(currentReadIndex, currentReadIndex + chunkLength);
            if (binaryDataSlice.byteLength !== chunkLength) {
                console.warn(new Uint8Array(data));
                reject('corrupt transfer');
                return;
            }
            var typedArray;
            try {
                typedArray = new Int16Array(binaryDataSlice);
            }
            catch (e) {
                reject(e);
                return;
            }
            resolve({
                json: jsonPortion,
                typedArray: typedArray
            });
        });
    };
    CommandUtilityService.prototype.observableParseChunkedTransfer = function (data, typedArrayFormat) {
        var _this = this;
        typedArrayFormat = typedArrayFormat == undefined ? 'i16' : typedArrayFormat;
        return Observable.create(function (observer) {
            var firstChar = String.fromCharCode.apply(null, new Uint8Array(data.slice(0, 1)));
            if (isNaN(parseInt(firstChar, 16))) {
                observer.error('json or bad packet');
                return;
            }
            var chunkGuardLength = 100;
            var currentReadIndex = 0;
            var chunkLength;
            var chunkInfo = _this._findNewLineChar(chunkGuardLength, data, currentReadIndex);
            chunkLength = _this._getChunkLength(chunkInfo.stringBuffer);
            currentReadIndex = chunkInfo.endingIndex;
            var jsonPortion;
            try {
                jsonPortion = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(data.slice(currentReadIndex, currentReadIndex + chunkLength + 2))));
            }
            catch (e) {
                observer.error(e);
                return;
            }
            currentReadIndex = currentReadIndex + chunkLength + 2;
            chunkInfo = _this._findNewLineChar(chunkGuardLength, data, currentReadIndex);
            chunkLength = _this._getChunkLength(chunkInfo.stringBuffer);
            currentReadIndex = chunkInfo.endingIndex;
            var binaryDataSlice = data.slice(currentReadIndex, currentReadIndex + chunkLength);
            if (binaryDataSlice.byteLength !== chunkLength) {
                console.warn(new Uint8Array(data));
                observer.error('corrupt transfer');
                return;
            }
            var typedArray;
            try {
                switch (typedArrayFormat) {
                    case 'i16':
                        typedArray = new Int16Array(binaryDataSlice);
                        break;
                    case 'u8':
                        typedArray = new Uint8Array(binaryDataSlice);
                        break;
                    default:
                        typedArray = new Int16Array(binaryDataSlice);
                }
            }
            catch (e) {
                observer.error(e);
                return;
            }
            observer.next({
                json: jsonPortion,
                typedArray: typedArray
            });
            observer.complete();
        });
    };
    CommandUtilityService.prototype._getChunkLength = function (chunkString) {
        return parseInt(chunkString, 16);
    };
    CommandUtilityService.prototype._findNewLineChar = function (maxLength, data, startIndex) {
        var char = '';
        var i = startIndex;
        maxLength = maxLength + i;
        var stringBuffer = '';
        while (i < maxLength && char !== '\n') {
            char = String.fromCharCode.apply(null, new Int8Array(data.slice(i, i + 1)));
            stringBuffer += char;
            i++;
        }
        var returnInfo = {
            stringBuffer: stringBuffer,
            endingIndex: i
        };
        return returnInfo;
    };
    CommandUtilityService.prototype.createInt16ArrayBuffer = function (array) {
        if (array.length % 2 !== 0) {
            throw new Error('Array length must be multiple of two!');
        }
        var arrayBufferView = new Int16Array(array);
        return arrayBufferView.buffer;
    };
    CommandUtilityService.prototype.createArrayBufferFromString = function (source) {
        var arrayBuffer = new ArrayBuffer(source.length);
        var bufView = new Uint8Array(arrayBuffer);
        for (var i = 0; i < source.length; i < i++) {
            bufView[i] = source.charCodeAt(i);
        }
        return arrayBuffer;
    };
    CommandUtilityService.prototype.createChunkedArrayBuffer = function (jsonObject, arrayBuffer) {
        var jsonString = JSON.stringify(jsonObject);
        var jsonStringLength = jsonString.length.toString(16);
        var arrayBufferLength = arrayBuffer.byteLength.toString(16);
        var beginningString = jsonStringLength + '\r\n' + jsonString + '\r\n' + arrayBufferLength + '\r\n';
        var endString = '\r\n0\r\n\r\n';
        var startArrayBuffer = this.createArrayBufferFromString(beginningString);
        var endingArrayBuffer = this.createArrayBufferFromString(endString);
        var temp = new Uint8Array(startArrayBuffer.byteLength + arrayBuffer.byteLength + endingArrayBuffer.byteLength);
        temp.set(new Uint8Array(startArrayBuffer), 0);
        temp.set(new Uint8Array(arrayBuffer), startArrayBuffer.byteLength);
        temp.set(new Uint8Array(endingArrayBuffer), startArrayBuffer.byteLength + arrayBuffer.byteLength);
        //Since we're actually sending the result directly to the transport, return the actual byte array instead of the arrayBuffer which is just a reference.
        return temp;
    };
    CommandUtilityService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    CommandUtilityService.ctorParameters = [];
    return CommandUtilityService;
}());
//# sourceMappingURL=command-utility.service.js.map