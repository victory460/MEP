var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/Rx';
import { GenericTransportService } from './generic-transport.service';
import { SimulatedDeviceService } from '../simulated-device/simulated-device.service';
export var LocalTransportService = (function (_super) {
    __extends(LocalTransportService, _super);
    function LocalTransportService(deviceEnumeration) {
        _super.call(this);
        this.streamState = {
            mode: 'off',
            remainingSamples: 0
        };
        this.simulatedDevice = new SimulatedDeviceService(deviceEnumeration);
    }
    LocalTransportService.prototype.getUri = function () {
        return this.rootUri;
    };
    LocalTransportService.prototype.setTimeout = function (newTimeout) { };
    LocalTransportService.prototype.getRequest = function (requestUrl, timeout) {
        return Observable.create(function (observer) {
            observer.error('Local transport does not support get requests');
        });
    };
    //Data transmission wrapper to avoid duplicate code. 
    LocalTransportService.prototype.writeRead = function (endpoint, sendData, dataType) {
        return this.writeReadHelper(this.rootUri, endpoint, sendData, dataType);
    };
    LocalTransportService.prototype.writeReadHelper = function (rootUri, endpoint, sendData, dataType) {
        var _this = this;
        var body = sendData;
        return Observable.create(function (observer) {
            _this.simulatedDevice.send(body).subscribe(function (data) {
                observer.next(data);
            }, function (err) {
                observer.error(err);
            }, function () {
            });
        });
    };
    //Stream via back to back xhr calls
    LocalTransportService.prototype.streamFrom = function (endpoint, sendData, dataType, delay) {
        var _this = this;
        if (delay === void 0) { delay = 0; }
        this.streamState.mode = 'continuous';
        return Observable.create(function (observer) {
            var i = 0;
            var getData = function (writeReadHelper, streamState, rootUri, endpoint, sendData, delay) {
                writeReadHelper(rootUri, endpoint, sendData).subscribe(function (data) {
                    observer.next(data);
                }, function (err) {
                    observer.error(err);
                    return;
                }, function () {
                    i++;
                    if (streamState.mode == 'continuous') {
                        //Wrap getData in anaonymous function to allow passing parameters to setTimeout handler
                        setTimeout(function () {
                            getData(writeReadHelper, streamState, rootUri, endpoint, sendData, delay);
                        }, delay);
                    }
                    else {
                        observer.complete();
                    }
                });
            };
            getData(_this.writeReadHelper, _this.streamState, _this.rootUri, endpoint, sendData, delay);
        });
    };
    //Sets stream to off
    LocalTransportService.prototype.stopStream = function () {
        this.streamState.mode = 'off';
    };
    //Get transport type
    LocalTransportService.prototype.getType = function () {
        return 'local';
    };
    LocalTransportService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    LocalTransportService.ctorParameters = [
        null,
    ];
    return LocalTransportService;
}(GenericTransportService));
//# sourceMappingURL=local-transport.service.js.map