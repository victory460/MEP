var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/Rx';
import { GenericTransportService } from './generic-transport.service';
export var HttpTransportService = (function (_super) {
    __extends(HttpTransportService, _super);
    function HttpTransportService(_rootUri, timeout) {
        _super.call(this);
        this.timeoutMinMs = 500;
        this.timeoutMaxMs = 120000;
        console.log('Transport HTTP Contructor');
        this.rootUri = _rootUri;
        this.streamState = {
            mode: 'off',
            remainingSamples: 0
        };
        this.timeout = this.forceRange(timeout, this.timeoutMinMs, this.timeoutMaxMs);
    }
    HttpTransportService.prototype.getUri = function () {
        return this.rootUri;
    };
    HttpTransportService.prototype.setTimeout = function (newTimeout) {
        this.timeout = this.forceRange(newTimeout, this.timeoutMinMs, this.timeoutMaxMs);
    };
    HttpTransportService.prototype.forceRange = function (val, min, max) {
        return Math.min(Math.max(min, val), max);
    };
    HttpTransportService.prototype.getRequest = function (requestUrl, timeout) {
        var _this = this;
        timeout = timeout == undefined ? this.timeout : this.forceRange(timeout, this.timeoutMinMs, this.timeoutMaxMs);
        return Observable.create(function (observer) {
            var XHR = new XMLHttpRequest();
            XHR.addEventListener("load", function (event) {
                _this.finish = performance.now();
                console.log('from start to fin');
                console.log(_this.finish - _this.start);
                observer.next(event.currentTarget.response);
                observer.complete();
            });
            XHR.addEventListener("error", function (event) {
                observer.error('Get Request Error', event);
            });
            XHR.addEventListener("timeout", function (event) {
                observer.error('Timeout', event);
            });
            try {
                XHR.open("GET", requestUrl);
                XHR.timeout = timeout;
                XHR.send();
                _this.start = performance.now();
                console.log('command sent');
            }
            catch (err) {
                observer.error('TX Error: ', event);
            }
        });
    };
    //Data transmission wrapper to avoid duplicate code. 
    HttpTransportService.prototype.writeRead = function (endpoint, sendData, dataType, timeout) {
        return this.writeReadHelper(this.rootUri, endpoint, sendData, dataType, timeout);
    };
    HttpTransportService.prototype.writeReadHelper = function (rootUri, endpoint, sendData, dataType, timeout) {
        var _this = this;
        var uri = rootUri + endpoint;
        var body = sendData;
        timeout = timeout == undefined ? this.timeout : this.forceRange(timeout, this.timeoutMinMs, this.timeoutMaxMs);
        console.log(body);
        return Observable.create(function (observer) {
            var XHR = new XMLHttpRequest();
            // We define what will happen if the data are successfully sent
            XHR.addEventListener("load", function (event) {
                _this.finish = performance.now();
                console.log('from start to fin');
                console.log(_this.finish - _this.start);
                observer.next(event.currentTarget.response);
                observer.complete();
            });
            // We define what will happen in case of error
            XHR.addEventListener("error", function (event) {
                observer.error('TX Error: ', event);
            });
            XHR.addEventListener("timeout", function (event) {
                observer.error('HTTP Timeout: ', event);
            });
            // We set up our request
            try {
                XHR.open("POST", uri);
                if (dataType === 'json') {
                    XHR.setRequestHeader("Content-Type", "application/json");
                }
                else if (dataType === 'binary') {
                    XHR.setRequestHeader("Content-Type", "application/octet-stream");
                }
                XHR.timeout = timeout;
                //Set resposne type as arraybuffer to receive response as bytes
                XHR.responseType = 'arraybuffer';
                XHR.send(body);
                _this.start = performance.now();
                console.log('command sent');
            }
            catch (err) {
                observer.error('TX Error: ', event);
            }
        });
    };
    //Stream via back to back xhr calls
    HttpTransportService.prototype.streamFrom = function (endpoint, sendData, dataType, delay) {
        var _this = this;
        if (delay === void 0) { delay = 0; }
        this.streamState.mode = 'continuous';
        return Observable.create(function (observer) {
            var i = 0;
            var getData = function (writeReadHelper, streamState, rootUri, endpoint, sendData, delay) {
                writeReadHelper(rootUri, endpoint, sendData).subscribe(function (data) {
                    //console.log('Inner Read ', i, ' >> ', data);
                    observer.next(data);
                }, function (err) {
                    console.log(err);
                }, function () {
                    i++;
                    if (streamState.mode == 'continuous') {
                        //Wrap getData in anaonymous function to allow passing parameters to setTimeout handler
                        setTimeout(function () {
                            getData(writeReadHelper, streamState, rootUri, endpoint, sendData, delay);
                        }, delay);
                    }
                    else {
                        observer.complete();
                    }
                });
            };
            getData(_this.writeReadHelper, _this.streamState, _this.rootUri, endpoint, sendData, delay);
        });
    };
    //Sets stream to off
    HttpTransportService.prototype.stopStream = function () {
        this.streamState.mode = 'off';
    };
    //Get transport type
    HttpTransportService.prototype.getType = function () {
        return 'http';
    };
    HttpTransportService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    HttpTransportService.ctorParameters = [
        null,
        null,
    ];
    return HttpTransportService;
}(GenericTransportService));
//# sourceMappingURL=http-transport.service.js.map