import { Injectable } from '@angular/core';
import { SimulatedDeviceHelperService } from '../simulated-device-helper.service';
export var SimulatedOscService = (function () {
    function SimulatedOscService(_simulatedDeviceService) {
        this.buffers = [
            [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000],
            [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000],
            [],
            [],
            [],
            []
        ];
        this.offsets = [0, 0, 0];
        this.gains = [1, 1, 1];
        this.sampleFreqs = [0, 0, 0, 0, 0, 0, 0];
        this.bufferSizes = [0, 0, 0, 0, 0, 0, 0];
        this.delays = [0, 0, 0, 0, 0, 0, 0, 0];
        this.defaultAwgSettings = {
            signalType: 'sine',
            signalFreq: 1000000,
            vpp: 3000,
            vOffset: 0
        };
        this.defaultOscSettings = {
            sampleFreq: 3000000,
            bufferSize: 10000
        };
        this.simulatedDeviceService = _simulatedDeviceService;
    }
    SimulatedOscService.prototype.setParameters = function (chan, commandObject) {
        this.offsets[chan] = commandObject.offset;
        this.gains[chan] = commandObject.gain;
        this.sampleFreqs[chan] = commandObject.sampleFreq;
        this.bufferSizes[chan] = commandObject.bufferSize;
        this.delays[chan] = commandObject.triggerDelay;
        this.simulatedDeviceService.setOscParameters(commandObject, chan);
        return {
            "command": "setParameters",
            "actualOffset": commandObject.offset,
            "actualSampleFreq": commandObject.sampleFreq,
            "statusCode": 0,
            "wait": 0
        };
    };
    SimulatedOscService.prototype.read = function (chan) {
        var targets = this.simulatedDeviceService.getTriggerTargets();
        var returnInfo = {};
        if (targets.osc.indexOf(parseInt(chan)) !== -1) {
            var awgSettings = this.simulatedDeviceService.getAwgSettings(1);
            var oscSettings = this.simulatedDeviceService.getOscParameters(chan);
            if (!this.simulatedDeviceService.getTriggerArmed()) {
                returnInfo = this.drawDefault();
            }
            else {
                if (awgSettings.signalType === 'sine') {
                    returnInfo = this.drawSine(awgSettings, oscSettings, chan);
                }
                else if (awgSettings.signalType === 'triangle') {
                    returnInfo = this.drawTriangle(awgSettings, oscSettings, chan);
                }
                else if (awgSettings.signalType === 'sawtooth') {
                    returnInfo = this.drawSawtooth(awgSettings, oscSettings, chan);
                }
                else if (awgSettings.signalType === 'square') {
                    returnInfo = this.drawSquare(awgSettings, oscSettings, chan);
                }
                else if (awgSettings.signalType === 'dc') {
                    returnInfo = this.drawDc(awgSettings, oscSettings, chan);
                }
                else {
                    console.log('drawing default wave');
                    returnInfo = this.drawDefault();
                }
            }
        }
        return returnInfo;
    };
    SimulatedOscService.prototype.drawDefault = function () {
        var numSamples = 32640;
        var sampleRate = 6250000000; //30 points per period
        var vOffset = 0; //in mV
        //Calculate dt - time between data points
        var dt = 1000 / sampleRate;
        //Clock time in seconds.  Rolls ever every hour.
        //Build Y point arrays
        var y = [];
        for (var j = 0; j < numSamples; j++) {
            y[j] = 0;
        }
        var typedArray = new Int16Array(y);
        return {
            command: "read",
            statusCode: 0,
            binaryLength: 2 * typedArray.length,
            binaryOffset: null,
            acqCount: 3,
            actualSampleFreq: 1000 / dt,
            y: typedArray,
            pointOfInterest: numSamples / 2,
            triggerIndex: numSamples / 2,
            triggerDelay: 0,
            actualVOffset: vOffset,
            actualGain: 1
        };
    };
    SimulatedOscService.prototype.drawSine = function (awgSettings, oscSettings, chan) {
        //---------- Simulate Signal ----------
        //Set default values
        var numSamples = oscSettings.bufferSize;
        var sigFreq = awgSettings.signalFreq; //in mHz
        var sampleRate = oscSettings.sampleFreq; //30 points per period
        var t0 = 0;
        var vOffset = awgSettings.vOffset; //in mV
        var vpp = awgSettings.vpp; //mV
        //Calculate dt - time between data points
        var dt = 1000 / sampleRate;
        var phase = ((parseInt(chan) - 1) * (90)) * (Math.PI / 180); //in radians
        //Clock time in seconds.  Rolls ever every hour.
        //Build Y point arrays
        var y = [];
        for (var j = 0; j < numSamples; j++) {
            y[j] = (vpp / 2) * (Math.sin((2 * Math.PI * (sigFreq / 1000)) * dt * j + t0 + phase)) + vOffset;
        }
        var typedArray = new Int16Array(y);
        //length is 2x the array length because 2 bytes per entry
        return {
            command: "read",
            statusCode: 0,
            binaryLength: 2 * typedArray.length,
            binaryOffset: null,
            acqCount: 3,
            actualSampleFreq: 1000 / dt,
            y: typedArray,
            pointOfInterest: numSamples / 2,
            triggerIndex: numSamples / 2,
            triggerDelay: 0,
            actualVOffset: vOffset,
            actualGain: 1
        };
    };
    SimulatedOscService.prototype.drawSquare = function (awgSettings, oscSettings, chan) {
        //Set default values
        var numSamples = oscSettings.bufferSize; //ten thousand points 
        var sigFreq = awgSettings.signalFreq; //in mHz
        var sampleRate = oscSettings.sampleFreq; //30 points per period
        var t0 = 0;
        var vOffset = awgSettings.vOffset; //in mV
        var vpp = awgSettings.vpp; //mV
        var dutyCycle = 50;
        //Calculate dt - time between data points
        var dt = 1000 / sampleRate;
        var y = [];
        var period = 1 / (sigFreq / 1000);
        var phase = (parseInt(chan) - 1) * (period / 4);
        for (var i = 0; i < numSamples; i++) {
            if ((dt * i + t0 + phase) % period < period * (dutyCycle / 100)) {
                y[i] = (vOffset + vpp / 2);
            }
            else {
                y[i] = (vOffset - vpp / 2);
            }
        }
        var typedArray = new Int16Array(y);
        //length is 2x the array length because 2 bytes per entry
        return {
            command: "read",
            statusCode: 0,
            binaryLength: 2 * typedArray.length,
            binaryOffset: null,
            acqCount: 3,
            actualSampleFreq: 1000 / dt,
            y: typedArray,
            pointOfInterest: numSamples / 2,
            triggerIndex: numSamples / 2,
            triggerDelay: 0,
            actualVOffset: vOffset,
            actualGain: 1
        };
    };
    SimulatedOscService.prototype.drawTriangle = function (awgSettings, oscSettings, chan) {
        var numSamples = oscSettings.bufferSize; //ten thousand points 
        var sigFreq = awgSettings.signalFreq; //in mHz
        var sampleRate = oscSettings.sampleFreq; //30 points per period
        var t0 = 0;
        var vOffset = awgSettings.vOffset; //in mV
        var vpp = awgSettings.vpp; //mV
        //Calculate dt - time between data points
        var dt = 1000 / sampleRate;
        var y = [];
        var period = 1 / (sigFreq / 1000);
        var phase = (parseInt(chan) - 1) * (period / 4);
        for (var i = 0; i < numSamples; i++) {
            y[i] = ((4 * (vpp / 2)) / period) * (Math.abs(((i * dt + t0 + phase + 3 * period / 4) % period) - period / 2) - period / 4) + vOffset;
        }
        var typedArray = new Int16Array(y);
        //length is 2x the array length because 2 bytes per entry
        return {
            command: "read",
            statusCode: 0,
            binaryLength: 2 * typedArray.length,
            binaryOffset: null,
            acqCount: 3,
            actualSampleFreq: 1000 / dt,
            y: typedArray,
            pointOfInterest: numSamples / 2,
            triggerIndex: numSamples / 2,
            triggerDelay: 0,
            actualVOffset: vOffset,
            actualGain: 1
        };
    };
    SimulatedOscService.prototype.drawSawtooth = function (awgSettings, oscSettings, chan) {
        var numSamples = oscSettings.bufferSize; //ten thousand points 
        var sigFreq = awgSettings.signalFreq; //in mHz
        var sampleRate = oscSettings.sampleFreq; //30 points per period
        var t0 = 0;
        var vOffset = awgSettings.vOffset; //in mV
        var vpp = awgSettings.vpp; //mV
        //Calculate dt - time between data points
        var dt = 1000 / sampleRate;
        var y = [];
        var period = 1 / (sigFreq / 1000);
        var phase = (parseInt(chan) - 1) * (period / 4);
        for (var i = 0; i < numSamples; i++) {
            y[i] = (vpp / period) * ((dt * i + t0 + phase) % period) + vOffset;
        }
        var typedArray = new Int16Array(y);
        //length is 2x the array length because 2 bytes per entry
        return {
            command: "read",
            statusCode: 0,
            binaryLength: 2 * typedArray.length,
            binaryOffset: null,
            acqCount: 3,
            actualSampleFreq: 1000 / dt,
            y: typedArray,
            pointOfInterest: numSamples / 2,
            triggerIndex: numSamples / 2,
            triggerDelay: 0,
            actualVOffset: vOffset,
            actualGain: 1
        };
    };
    SimulatedOscService.prototype.drawDc = function (awgSettings, oscSettings, chan) {
        var numSamples = oscSettings.bufferSize; //ten thousand points
        var sampleRate = oscSettings.sampleFreq; //30 points per period
        var vOffset = awgSettings.vOffset; //in mV
        //Calculate dt - time between data points
        var dt = 1000 / sampleRate;
        var y = [];
        for (var i = 0; i < numSamples; i++) {
            y[i] = vOffset;
        }
        var typedArray = new Int16Array(y);
        return {
            command: "read",
            statusCode: 0,
            binaryLength: 2 * typedArray.length,
            binaryOffset: null,
            acqCount: 3,
            actualSampleFreq: 1000 / dt,
            y: typedArray,
            pointOfInterest: numSamples / 2,
            triggerIndex: numSamples / 2,
            triggerDelay: 0,
            actualVOffset: vOffset,
            actualGain: 1
        };
    };
    SimulatedOscService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    SimulatedOscService.ctorParameters = [
        { type: SimulatedDeviceHelperService, },
    ];
    return SimulatedOscService;
}());
//# sourceMappingURL=simulated-osc.service.js.map